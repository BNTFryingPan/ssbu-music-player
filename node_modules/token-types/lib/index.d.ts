/// <reference types="node" />
export interface IGetToken<T> {
    /**
     * Length in bytes of encoded value
     */
    len: number;
    /**
     * Decode value from buffer at offset
     * @param buf Buffer to read the decoded value from
     * @param off Decode offset
     */
    get(buf: Buffer, off: number): T;
}
export interface IToken<T> extends IGetToken<T> {
    /**
     * Encode value to buffer
     * @param buffer Buffer to write the encoded value to
     * @param offset Buffer write offset
     * @param value Value to decode of type T
     * @param flush ToDo
     */
    put(buffer: Buffer, offset: number, value: T, flush?: IFlush): number;
}
export declare type IFlush = (b: Buffer, o: number) => void;
/**
 * 8-bit unsigned integer
 */
export declare const UINT8: IToken<number>;
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
export declare const UINT16_LE: IToken<number>;
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
export declare const UINT16_BE: IToken<number>;
/**
 * 24-bit unsigned integer, Little Endian byte order
 */
export declare const UINT24_LE: IToken<number>;
/**
 * 24-bit unsigned integer, Big Endian byte order
 */
export declare const UINT24_BE: IToken<number>;
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
export declare const UINT32_LE: IToken<number>;
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
export declare const UINT32_BE: IToken<number>;
/**
 * 8-bit signed integer
 */
export declare const INT8: IToken<number>;
/**
 * 16-bit signed integer, Big Endian byte order
 */
export declare const INT16_BE: IToken<number>;
/**
 * 16-bit signed integer, Little Endian byte order
 */
export declare const INT16_LE: IToken<number>;
/**
 * 24-bit signed integer, Little Endian byte order
 */
export declare const INT24_LE: IToken<number>;
/**
 * 24-bit signed integer, Big Endian byte order
 */
export declare const INT24_BE: IToken<number>;
/**
 * 32-bit signed integer, Big Endian byte order
 */
export declare const INT32_BE: IToken<number>;
/**
 * 32-bit signed integer, Big Endian byte order
 */
export declare const INT32_LE: IToken<number>;
/**
 * 64-bit unsigned integer, Little Endian byte order
 */
export declare const UINT64_LE: IToken<number>;
/**
 * 64-bit signed integer, Little Endian byte order
 */
export declare const INT64_LE: IToken<number>;
/**
 * 64-bit unsigned integer, Big Endian byte order
 */
export declare const UINT64_BE: IToken<number>;
/**
 * 64-bit signed integer, Big Endian byte order
 */
export declare const INT64_BE: IToken<number>;
/**
 * Ignore a given number of bytes
 */
export declare class IgnoreType implements IGetToken<void> {
    len: number;
    /**
     * @param len number of bytes to ignore
     */
    constructor(len: number);
    get(buf: Buffer, off: number): void;
}
export declare class BufferType implements IGetToken<Buffer> {
    len: number;
    constructor(len: number);
    get(buf: Buffer, off: number): Buffer;
}
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
export declare class StringType implements IGetToken<string> {
    len: number;
    encoding: string;
    constructor(len: number, encoding: string);
    get(buf: Buffer, off: number): string;
}
/**
 * ANSI Latin 1 String
 * Using windows-1252 / ISO 8859-1 decoding
 */
export declare class AnsiStringType implements IGetToken<string> {
    len: number;
    private static windows1252;
    private static decode;
    private static inRange;
    private static codePointToString;
    private static singleByteDecoder;
    constructor(len: number);
    get(buf: Buffer, off?: number): string;
}
/**
 * Best effort approach to write 64 but signed integer, little endian.
 * Note that JavasScript is limited to 2^53 - 1 bit.
 */
export declare function writeIntLE(buf: Buffer, value: number, offset: number, byteLength: number): number;
/**
 * Best effort approach to read up to 64 bit unsigned integer, big endian.
 * Note that JavasScript is limited to 2^53 - 1 bit.
 */
export declare function readUIntBE(buf: Buffer, offset: number, byteLength: number): number;
/**
 * Best effort approach to write up to 64 bit unsigned integer, big endian.
 * Note that JavasScript is limited to 2^53 - 1 bit.
 */
export declare function writeUIntBE(buf: Buffer, value: number, offset: number, byteLength: number): number;
/**
 * Best effort approach to read 64 but signed integer, big endian.
 * Note that JavasScript is limited to 2^53 - 1 bit.
 */
export declare function readIntBE(buf: Buffer, offset: number, byteLength: number): number;
/**
 * Best effort approach to write 64 but signed integer, big endian.
 * Note that JavasScript is limited to 2^53 - 1 bit.
 */
export declare function writeIntBE(buf: Buffer, value: number, offset: number, byteLength: number): number;
